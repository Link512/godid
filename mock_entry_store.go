// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package godid

import (
	"sync"
	"time"
)

// Ensure, that entryStoreMock does implement entryStore.
// If this is not the case, regenerate this file with moq.
var _ entryStore = &entryStoreMock{}

// entryStoreMock is a mock implementation of entryStore.
//
//	func TestSomethingThatUsesentryStore(t *testing.T) {
//
//		// make and configure a mocked entryStore
//		mockedentryStore := &entryStoreMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			GetRangeFunc: func(parentBucketName string, start time.Time, end time.Time) ([]entry, error) {
//				panic("mock out the GetRange method")
//			},
//			GetRangeWithAggregationFunc: func(parentBucketName string, start time.Time, end time.Time, agg aggregationFunction) (any, error) {
//				panic("mock out the GetRangeWithAggregation method")
//			},
//			PutFunc: func(s string, entryMoqParam entry) error {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedentryStore in code that requires entryStore
//		// and then make assertions.
//
//	}
type entryStoreMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// GetRangeFunc mocks the GetRange method.
	GetRangeFunc func(parentBucketName string, start time.Time, end time.Time) ([]entry, error)

	// GetRangeWithAggregationFunc mocks the GetRangeWithAggregation method.
	GetRangeWithAggregationFunc func(parentBucketName string, start time.Time, end time.Time, agg aggregationFunction) (any, error)

	// PutFunc mocks the Put method.
	PutFunc func(s string, entryMoqParam entry) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// GetRange holds details about calls to the GetRange method.
		GetRange []struct {
			// ParentBucketName is the parentBucketName argument value.
			ParentBucketName string
			// Start is the start argument value.
			Start time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetRangeWithAggregation holds details about calls to the GetRangeWithAggregation method.
		GetRangeWithAggregation []struct {
			// ParentBucketName is the parentBucketName argument value.
			ParentBucketName string
			// Start is the start argument value.
			Start time.Time
			// End is the end argument value.
			End time.Time
			// Agg is the agg argument value.
			Agg aggregationFunction
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// S is the s argument value.
			S string
			// EntryMoqParam is the entryMoqParam argument value.
			EntryMoqParam entry
		}
	}
	lockClose                   sync.RWMutex
	lockGetRange                sync.RWMutex
	lockGetRangeWithAggregation sync.RWMutex
	lockPut                     sync.RWMutex
}

// Close calls CloseFunc.
func (mock *entryStoreMock) Close() error {
	if mock.CloseFunc == nil {
		panic("entryStoreMock.CloseFunc: method is nil but entryStore.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedentryStore.CloseCalls())
func (mock *entryStoreMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetRange calls GetRangeFunc.
func (mock *entryStoreMock) GetRange(parentBucketName string, start time.Time, end time.Time) ([]entry, error) {
	if mock.GetRangeFunc == nil {
		panic("entryStoreMock.GetRangeFunc: method is nil but entryStore.GetRange was just called")
	}
	callInfo := struct {
		ParentBucketName string
		Start            time.Time
		End              time.Time
	}{
		ParentBucketName: parentBucketName,
		Start:            start,
		End:              end,
	}
	mock.lockGetRange.Lock()
	mock.calls.GetRange = append(mock.calls.GetRange, callInfo)
	mock.lockGetRange.Unlock()
	return mock.GetRangeFunc(parentBucketName, start, end)
}

// GetRangeCalls gets all the calls that were made to GetRange.
// Check the length with:
//
//	len(mockedentryStore.GetRangeCalls())
func (mock *entryStoreMock) GetRangeCalls() []struct {
	ParentBucketName string
	Start            time.Time
	End              time.Time
} {
	var calls []struct {
		ParentBucketName string
		Start            time.Time
		End              time.Time
	}
	mock.lockGetRange.RLock()
	calls = mock.calls.GetRange
	mock.lockGetRange.RUnlock()
	return calls
}

// GetRangeWithAggregation calls GetRangeWithAggregationFunc.
func (mock *entryStoreMock) GetRangeWithAggregation(parentBucketName string, start time.Time, end time.Time, agg aggregationFunction) (any, error) {
	if mock.GetRangeWithAggregationFunc == nil {
		panic("entryStoreMock.GetRangeWithAggregationFunc: method is nil but entryStore.GetRangeWithAggregation was just called")
	}
	callInfo := struct {
		ParentBucketName string
		Start            time.Time
		End              time.Time
		Agg              aggregationFunction
	}{
		ParentBucketName: parentBucketName,
		Start:            start,
		End:              end,
		Agg:              agg,
	}
	mock.lockGetRangeWithAggregation.Lock()
	mock.calls.GetRangeWithAggregation = append(mock.calls.GetRangeWithAggregation, callInfo)
	mock.lockGetRangeWithAggregation.Unlock()
	return mock.GetRangeWithAggregationFunc(parentBucketName, start, end, agg)
}

// GetRangeWithAggregationCalls gets all the calls that were made to GetRangeWithAggregation.
// Check the length with:
//
//	len(mockedentryStore.GetRangeWithAggregationCalls())
func (mock *entryStoreMock) GetRangeWithAggregationCalls() []struct {
	ParentBucketName string
	Start            time.Time
	End              time.Time
	Agg              aggregationFunction
} {
	var calls []struct {
		ParentBucketName string
		Start            time.Time
		End              time.Time
		Agg              aggregationFunction
	}
	mock.lockGetRangeWithAggregation.RLock()
	calls = mock.calls.GetRangeWithAggregation
	mock.lockGetRangeWithAggregation.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *entryStoreMock) Put(s string, entryMoqParam entry) error {
	if mock.PutFunc == nil {
		panic("entryStoreMock.PutFunc: method is nil but entryStore.Put was just called")
	}
	callInfo := struct {
		S             string
		EntryMoqParam entry
	}{
		S:             s,
		EntryMoqParam: entryMoqParam,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(s, entryMoqParam)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedentryStore.PutCalls())
func (mock *entryStoreMock) PutCalls() []struct {
	S             string
	EntryMoqParam entry
} {
	var calls []struct {
		S             string
		EntryMoqParam entry
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}
